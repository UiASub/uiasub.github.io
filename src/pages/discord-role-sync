// Edge Function: discord-role-sync (Deno)
// Role-check + proxy actions (check, list_files, sign_file, download_file, delete_file,
// plus equipment CRUD). This version uses JSDoc annotations so Supabase's editor/typechecker
// won't complain about missing properties like retryAfter/check/action/payload.
//
// Required env vars: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, DISCORD_BOT_TOKEN, GUILD_ID, REQUIRED_ROLE_ID
console.info('discord-role-sync function starting');
const SUPABASE_URL = Deno.env.get('SUPABASE_URL') ?? '';
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '';
const DISCORD_BOT_TOKEN = Deno.env.get('DISCORD_BOT_TOKEN') ?? '';
const GUILD_ID = Deno.env.get('GUILD_ID') ?? '';
const REQUIRED_ROLE_ID = Deno.env.get('REQUIRED_ROLE_ID') ?? '';
if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY || !DISCORD_BOT_TOKEN || !GUILD_ID || !REQUIRED_ROLE_ID) {
  console.error('Missing required environment variables.');
  throw new Error('discord-role-sync misconfigured: missing required env vars');
}
const ALLOWED_ORIGINS = new Set([
  'https://uiasub.github.io',
  'https://uiasub.no',
  'http://localhost:8080'
]);
function normalizeOrigin(o) {
  if (!o) return undefined;
  try {
    const u = new URL(o);
    const origin = `${u.protocol}//${u.hostname}${u.port ? `:${u.port}` : ''}`;
    return origin.endsWith('/') ? origin.slice(0, -1) : origin;
  } catch  {
    const trimmed = (o || '').trim();
    return trimmed.endsWith('/') ? trimmed.slice(0, -1) : trimmed;
  }
}
function corsHeaders(origin) {
  const norm = normalizeOrigin(origin);
  if (norm && ALLOWED_ORIGINS.has(norm)) {
    return {
      'Access-Control-Allow-Origin': norm,
      'Access-Control-Allow-Headers': 'Authorization, Content-Type',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Credentials': 'true',
      'Vary': 'Origin',
      'Access-Control-Max-Age': '600'
    };
  }
  return {
    'Vary': 'Origin'
  };
}
function jsonResponse(body, status = 200, origin) {
  const headers = {
    'Content-Type': 'application/json',
    ...corsHeaders(origin)
  };
  return new Response(JSON.stringify(body), {
    status,
    headers
  });
}
function isErrorLike(e) {
  return typeof e === 'object' && e !== null;
}
class DiscordRateLimitError extends Error {
  constructor(message, retryAfter){
    super(message);
    this.name = 'DiscordRateLimitError';
    /** @type {number|undefined} */ this.retryAfter = retryAfter;
  }
}
async function fetchWithTimeout(resource, options = {}, timeoutMs = 8000) {
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeoutMs);
  try {
    const resp = await fetch(resource, {
      ...options,
      signal: controller.signal
    });
    return resp;
  } finally{
    clearTimeout(id);
  }
}
function parseRetryAfter(header) {
  if (!header) return undefined;
  const trimmed = header.trim();
  const num = Number(trimmed);
  if (!Number.isNaN(num)) return num;
  const parsed = Date.parse(trimmed);
  if (!Number.isNaN(parsed)) {
    const seconds = Math.max(0, Math.floor((parsed - Date.now()) / 1000));
    return seconds;
  }
  return trimmed;
}
function makeRequestId() {
  return crypto.randomUUID?.() ?? `${Date.now()}-${Math.floor(Math.random() * 1e6)}`;
}
/* ---------------------------
   Supabase / Discord helpers
   --------------------------- */ async function getUserFromAuth(jwt, timeoutMs = 5000) {
  const url = `${SUPABASE_URL}/auth/v1/user`;
  const resp = await fetchWithTimeout(url, {
    method: 'GET',
    headers: {
      Authorization: `Bearer ${jwt}`,
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Accept: 'application/json'
    }
  }, timeoutMs);
  if (!resp.ok) {
    const txt = await resp.text().catch(()=>'');
    throw new Error(`Auth user lookup failed: ${resp.status} ${txt}`);
  }
  return resp.json();
}
async function getDiscordIdentityForUser(userId, timeoutMs = 5000) {
  // Try RPC first
  try {
    const rpcResp = await fetchWithTimeout(`${SUPABASE_URL}/rest/v1/rpc/get_discord_identity`, {
      method: 'POST',
      headers: {
        apikey: SUPABASE_SERVICE_ROLE_KEY,
        Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
        'Content-Type': 'application/json',
        Accept: 'application/json'
      },
      body: JSON.stringify({
        p_user_id: userId
      })
    }, timeoutMs);
    if (rpcResp.ok) {
      const body = await rpcResp.json();
      if (Array.isArray(body) && body.length > 0) return body[0];
      return null;
    } else if (rpcResp.status === 404) {
      return null;
    } else {
      const txt = await rpcResp.text().catch(()=>'');
      console.warn('RPC returned non-ok:', rpcResp.status, txt);
    }
  } catch (e) {
    console.warn('RPC get_discord_identity error, falling back', String(e));
  }
  // Fallback to identities table
  const q = `user_id=eq.${encodeURIComponent(userId)}&provider=eq.discord`;
  const url = `${SUPABASE_URL}/rest/v1/identities?${q}&select=provider_id,provider,identity_data`;
  const resp = await fetchWithTimeout(url, {
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      Accept: 'application/json'
    }
  }, timeoutMs);
  if (!resp.ok) {
    const txt = await resp.text().catch(()=>'');
    throw new Error(`Failed to query auth.identities: ${resp.status} ${txt}`);
  }
  const rows = await resp.json();
  if (Array.isArray(rows) && rows.length > 0) return rows[0];
  return null;
}
async function discordGetMemberRoles(discordUserId, timeoutMs = 7000) {
  const url = `https://discord.com/api/v10/guilds/${GUILD_ID}/members/${discordUserId}`;
  const resp = await fetchWithTimeout(url, {
    headers: {
      Authorization: `Bot ${DISCORD_BOT_TOKEN}`,
      'Content-Type': 'application/json',
      Accept: 'application/json'
    }
  }, timeoutMs);
  if (resp.status === 404) return {
    member: false,
    roles: []
  };
  if (resp.status === 429) {
    const retryAfterHeader = resp.headers.get('Retry-After');
    const txt = await resp.text().catch(()=>'');
    const retryAfter = parseRetryAfter(retryAfterHeader);
    throw new DiscordRateLimitError(`Discord rate limited. ${retryAfterHeader ?? ''} ${txt}`, retryAfter);
  }
  if (!resp.ok) {
    const txt = await resp.text().catch(()=>'');
    throw new Error(`Discord API error: ${resp.status} ${txt}`);
  }
  const data = await resp.json();
  return {
    member: true,
    roles: Array.isArray(data.roles) ? data.roles : []
  };
}
async function upsertAllowedUser(discordId, email, name, actor, timeoutMs = 5000) {
  const url = `${SUPABASE_URL}/rest/v1/allowed_users?on_conflict=discord_id`;
  const payload = {
    discord_id: discordId,
    email,
    name,
    added_by: actor
  };
  const resp = await fetchWithTimeout(url, {
    method: 'POST',
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      'Content-Type': 'application/json',
      Prefer: 'return=representation'
    },
    body: JSON.stringify(payload)
  }, timeoutMs);
  if (!resp.ok) {
    const txt = await resp.text().catch(()=>'');
    if (resp.status === 409 && txt.includes('duplicate key value')) {
      return {
        ok: true,
        action: 'already_exists'
      };
    }
    throw new Error(`Upsert allowed_users failed: ${resp.status} ${txt}`);
  }
  return resp.json();
}
async function deleteAllowedUser(discordId, timeoutMs = 5000) {
  const url = `${SUPABASE_URL}/rest/v1/allowed_users?discord_id=eq.${encodeURIComponent(discordId)}`;
  const resp = await fetchWithTimeout(url, {
    method: 'DELETE',
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      Prefer: 'return=representation'
    }
  }, timeoutMs);
  if (!resp.ok) {
    const txt = await resp.text().catch(()=>'');
    throw new Error(`Delete allowed_users failed: ${resp.status} ${txt}`);
  }
  return true;
}
function parseIdentityData(identity_data) {
  if (!identity_data) return {};
  if (typeof identity_data === 'object') return identity_data;
  if (typeof identity_data === 'string') {
    try {
      return JSON.parse(identity_data);
    } catch  {
      return {};
    }
  }
  return {};
}
function extractRetryAfter(e) {
  if (e instanceof DiscordRateLimitError) return /** @type {any} */ e.retryAfter;
  if (isErrorLike(e) && 'retryAfter' in e) return /** @type {any} */ e.retryAfter;
  return undefined;
}
/* ---------------------------
   Supabase service-role wrappers
   --------------------------- */ async function supabaseGet(path) {
  const url = `${SUPABASE_URL}${path}`;
  const resp = await fetchWithTimeout(url, {
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      Accept: 'application/json'
    }
  }, 10000);
  const txt = await resp.text().catch(()=>null);
  try {
    return {
      ok: resp.ok,
      status: resp.status,
      data: txt ? JSON.parse(txt) : null,
      text: txt
    };
  } catch  {
    return {
      ok: resp.ok,
      status: resp.status,
      data: null,
      text: txt
    };
  }
}
async function supabasePost(path, body) {
  const url = `${SUPABASE_URL}${path}`;
  const resp = await fetchWithTimeout(url, {
    method: 'POST',
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      'Content-Type': 'application/json',
      Accept: 'application/json'
    },
    body: JSON.stringify(body)
  }, 10000);
  const txt = await resp.text().catch(()=>null);
  try {
    return {
      ok: resp.ok,
      status: resp.status,
      data: txt ? JSON.parse(txt) : null,
      text: txt
    };
  } catch  {
    return {
      ok: resp.ok,
      status: resp.status,
      data: null,
      text: txt
    };
  }
}
async function supabasePatch(path, body) {
  const url = `${SUPABASE_URL}${path}`;
  const resp = await fetchWithTimeout(url, {
    method: 'PATCH',
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      'Content-Type': 'application/json',
      Accept: 'application/json'
    },
    body: JSON.stringify(body)
  }, 10000);
  const txt = await resp.text().catch(()=>null);
  try {
    return {
      ok: resp.ok,
      status: resp.status,
      data: txt ? JSON.parse(txt) : null,
      text: txt
    };
  } catch  {
    return {
      ok: resp.ok,
      status: resp.status,
      data: null,
      text: txt
    };
  }
}
async function supabaseDelete(path) {
  const url = `${SUPABASE_URL}${path}`;
  const resp = await fetchWithTimeout(url, {
    method: 'DELETE',
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      Accept: 'application/json'
    }
  }, 10000);
  const txt = await resp.text().catch(()=>null);
  try {
    return {
      ok: resp.ok,
      status: resp.status,
      data: txt ? JSON.parse(txt) : null,
      text: txt
    };
  } catch  {
    return {
      ok: resp.ok,
      status: resp.status,
      data: null,
      text: txt
    };
  }
}
/* ---------------------------
   Main handler
   --------------------------- */ Deno.serve(async (req)=>{
  const requestId = makeRequestId();
  const origin = req.headers.get('origin');
  console.info({
    requestId,
    msg: 'request_start',
    method: req.method,
    origin
  });
  try {
    if (req.method === 'OPTIONS') {
      return new Response(null, {
        status: 204,
        headers: corsHeaders(origin)
      });
    }
    if (req.method !== 'POST') {
      return jsonResponse({
        error: 'Method not allowed'
      }, 405, origin);
    }
    const rawAuth = req.headers.get('authorization') ?? '';
    if (!rawAuth || !rawAuth.startsWith('Bearer ')) {
      return jsonResponse({
        error: 'Missing Bearer token'
      }, 401, origin);
    }
    const jwt = rawAuth.substring('Bearer '.length).trim();
    const contentTypeHeader = (req.headers.get('content-type') || '').toLowerCase();
    // If this is a multipart/form-data request (file upload), parse it and
    // handle the upload_file action directly. This keeps uploads proxied via
    // the service role key and avoids exposing secrets to the client.
    if (contentTypeHeader.includes('multipart/form-data')) {
      try {
        const form = await req.formData();
        const actionForm = String(form.get('action') || 'upload_file');
        if (actionForm !== 'upload_file') return jsonResponse({
          error: 'Unsupported multipart action'
        }, 400, origin);
        // Validate user
        let userMultipart;
        try {
          userMultipart = await getUserFromAuth(jwt);
        } catch (e) {
          console.warn({
            requestId,
            msg: 'auth_lookup_failed',
            err: isErrorLike(e) ? String(e.message ?? e) : String(e)
          });
          return jsonResponse({
            error: 'Invalid token'
          }, 401, origin);
        }
        const userIdMultipart = userMultipart?.id;
        if (!userIdMultipart) return jsonResponse({
          error: 'Authenticated user id not found'
        }, 401, origin);
        // Discord identity
        const discordIdentityMultipart = await getDiscordIdentityForUser(userIdMultipart);
        if (!discordIdentityMultipart || !discordIdentityMultipart.provider_id) {
          return jsonResponse({
            ok: false,
            reason: 'No Discord identity linked'
          }, 200, origin);
        }
        const discordUserIdMultipart = String(discordIdentityMultipart.provider_id);
        // Discord API roles
        let memberInfoMultipart;
        try {
          memberInfoMultipart = await discordGetMemberRoles(discordUserIdMultipart);
        } catch (err) {
          const ra = extractRetryAfter(err);
          const bodyErr = {
            error: 'Discord API error'
          };
          if (ra !== undefined) bodyErr.retryAfter = ra;
          return jsonResponse(bodyErr, 503, origin);
        }
        const hasRoleMultipart = memberInfoMultipart.member && memberInfoMultipart.roles.includes(REQUIRED_ROLE_ID);
        if (!hasRoleMultipart) return jsonResponse({
          error: 'Forbidden: you do not have the required role'
        }, 403, origin);
        // Extract file and params
        const fileField = form.get('file');
        if (!fileField) return jsonResponse({
          error: 'No file attached'
        }, 400, origin);
        // fileField should be a File (Blob)
        // @ts-ignore - treat as File-like
        const fileObj = /** @type {any} */ fileField;
        const fileName = String(form.get('name') || fileObj.name || 'upload.bin');
        const bucket = String(form.get('bucket') || 'Files');
        const contentTypeOfFile = fileObj.type || 'application/octet-stream';
        // Read file bytes
        let arrayBuffer;
        try {
          arrayBuffer = await fileObj.arrayBuffer();
        } catch (e) {
          return jsonResponse({
            error: 'Failed to read uploaded file'
          }, 400, origin);
        }
        // Proxy upload to Supabase Storage via PUT
        const uploadUrl = `${SUPABASE_URL}/storage/v1/object/${encodeURIComponent(bucket)}/${encodeURIComponent(fileName)}`;
        const upResp = await fetchWithTimeout(uploadUrl, {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': contentTypeOfFile
          },
          body: arrayBuffer
        }, 120000);
        const upText = await upResp.text().catch(()=>'');
        if (!upResp.ok) {
          console.error({
            requestId,
            msg: 'supabase_upload_failed',
            status: upResp.status,
            text: upText
          });
          return jsonResponse({
            error: 'Upload to storage failed',
            detail: upText
          }, upResp.status, origin);
        }
        return jsonResponse({
          ok: true,
          file: {
            name: fileName
          }
        }, 200, origin);
      } catch (e) {
        console.error({
          requestId,
          msg: 'multipart_handling_failed',
          err: isErrorLike(e) ? String(e.message ?? e) : String(e)
        });
        return jsonResponse({
          error: 'Multipart handling failed',
          detail: isErrorLike(e) ? e.message ?? String(e) : String(e)
        }, 500, origin);
      }
    }
    const bodyText = await req.text().catch(()=>'');
    /** @type {any} */ let body = {};
    try {
      body = bodyText ? JSON.parse(bodyText) : {};
    } catch  {
      body = {};
    }
    // Legacy check flow: { check: true }
    if (body && /** @type {any} */ body.check) {
      // Validate user
      let user;
      try {
        user = await getUserFromAuth(jwt);
      } catch (e) {
        console.warn({
          requestId,
          msg: 'auth_lookup_failed',
          err: isErrorLike(e) ? String(e.message ?? e) : String(e)
        });
        return jsonResponse({
          error: 'Invalid token'
        }, 401, origin);
      }
      const userId = user?.id;
      if (!userId) return jsonResponse({
        error: 'Authenticated user id not found'
      }, 401, origin);
      // Discord identity
      const discordIdentity = await getDiscordIdentityForUser(userId);
      if (!discordIdentity || !discordIdentity.provider_id) {
        return jsonResponse({
          ok: false,
          reason: 'No Discord identity linked'
        }, 200, origin);
      }
      const discordUserId = String(discordIdentity.provider_id);
      // Discord API roles
      let memberInfo;
      try {
        memberInfo = await discordGetMemberRoles(discordUserId);
      } catch (err) {
        const ra = extractRetryAfter(err);
        const bodyErr = {
          error: 'Discord API error'
        };
        if (ra !== undefined) bodyErr.retryAfter = ra;
        return jsonResponse(bodyErr, 503, origin);
      }
      const hasRole = memberInfo.member && memberInfo.roles.includes(REQUIRED_ROLE_ID);
      const actor = user.email ?? userId;
      if (hasRole) {
        try {
          const identityData = parseIdentityData(discordIdentity.identity_data);
          const email = identityData?.email ?? user.email ?? null;
          // Friendly name preference: identityData.username -> identityData.name -> raw_user_meta_data.full_name -> user.email
          const name = identityData?.username ?? identityData?.name ?? (user?.raw_user_meta_data && user.raw_user_meta_data.full_name) ?? user?.email ?? null;
          const upserted = await upsertAllowedUser(discordUserId, email, name, actor);
          return jsonResponse({
            ok: true,
            action: 'upserted',
            name: name ?? null,
            row: upserted
          }, 200, origin);
        } catch (e) {
          console.error({
            requestId,
            msg: 'db_upsert_failed',
            err: isErrorLike(e) ? String(e.message ?? e) : String(e)
          });
          return jsonResponse({
            error: 'DB upsert failed'
          }, 500, origin);
        }
      } else {
        try {
          await deleteAllowedUser(discordUserId);
          return jsonResponse({
            ok: true,
            action: 'deleted'
          }, 200, origin);
        } catch (e) {
          console.error({
            requestId,
            msg: 'db_delete_failed',
            err: isErrorLike(e) ? String(e.message ?? e) : String(e)
          });
          return jsonResponse({
            error: 'DB delete failed'
          }, 500, origin);
        }
      }
    }
    // From here expect { action, payload }
    /** @type {any} */ const action = body?.action;
    /** @type {any} */ const payload = body?.payload ?? {};
    if (!action) return jsonResponse({
      error: 'Missing action'
    }, 400, origin);
    // Validate user + required role (reuse flow)
    let user;
    try {
      user = await getUserFromAuth(jwt);
    } catch (e) {
      console.warn({
        requestId,
        msg: 'auth_lookup_failed',
        err: isErrorLike(e) ? String(e.message ?? e) : String(e)
      });
      return jsonResponse({
        error: 'Invalid token'
      }, 401, origin);
    }
    const userId = user?.id;
    if (!userId) return jsonResponse({
      error: 'Authenticated user id not found'
    }, 401, origin);
    const discordIdentity = await getDiscordIdentityForUser(userId);
    if (!discordIdentity || !discordIdentity.provider_id) {
      return jsonResponse({
        ok: false,
        reason: 'No Discord identity linked'
      }, 200, origin);
    }
    const discordUserId = String(discordIdentity.provider_id);
    let memberInfo;
    try {
      memberInfo = await discordGetMemberRoles(discordUserId);
    } catch (err) {
      const ra = extractRetryAfter(err);
      const bodyErr = {
        error: 'Discord API error'
      };
      if (ra !== undefined) bodyErr.retryAfter = ra;
      return jsonResponse(bodyErr, 503, origin);
    }
    const hasRole = memberInfo.member && memberInfo.roles.includes(REQUIRED_ROLE_ID);
    if (!hasRole) return jsonResponse({
      error: 'Forbidden: you do not have the required role'
    }, 403, origin);
    // Action router
    try {
      switch(action){
        case 'get_equipment':
          {
            const r = await supabaseGet('/rest/v1/equipment?order=name');
            if (!r.ok) return jsonResponse({
              error: 'Failed to fetch equipment',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true,
              data: r.data
            }, 200, origin);
          }
        case 'add_equipment':
          {
            const bodyPayload = {
              name: payload.name,
              description: payload.description ?? null,
              loaned_to: null,
              loaned_at: null
            };
            const r = await supabasePost('/rest/v1/equipment', bodyPayload);
            if (!r.ok) return jsonResponse({
              error: 'Failed to add equipment',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true,
              data: r.data
            }, 200, origin);
          }
        case 'assign_equipment':
          {
            const id = payload.id;
            if (!id) return jsonResponse({
              error: 'Missing id'
            }, 400, origin);
            const r = await supabasePatch(`/rest/v1/equipment?id=eq.${encodeURIComponent(id)}`, {
              loaned_to: payload.loaned_to ?? null,
              loaned_at: new Date().toISOString()
            });
            if (!r.ok) return jsonResponse({
              error: 'Failed to assign equipment',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true,
              data: r.data
            }, 200, origin);
          }
        case 'return_equipment':
          {
            const id = payload.id;
            if (!id) return jsonResponse({
              error: 'Missing id'
            }, 400, origin);
            const r = await supabasePatch(`/rest/v1/equipment?id=eq.${encodeURIComponent(id)}`, {
              loaned_to: null,
              loaned_at: null
            });
            if (!r.ok) return jsonResponse({
              error: 'Failed to return equipment',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true,
              data: r.data
            }, 200, origin);
          }
        case 'delete_equipment':
          {
            const id = payload.id;
            if (!id) return jsonResponse({
              error: 'Missing id'
            }, 400, origin);
            const r = await supabaseDelete(`/rest/v1/equipment?id=eq.${encodeURIComponent(id)}`);
            if (!r.ok) return jsonResponse({
              error: 'Failed to delete equipment',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true
            }, 200, origin);
          }
        case 'list_files':
          {
            const bucket = payload.bucket;
            const prefix = payload.prefix ?? '';
            if (!bucket) return jsonResponse({
              error: 'Missing bucket'
            }, 400, origin);
            const r = await supabasePost(`/storage/v1/object/list/${encodeURIComponent(bucket)}`, {
              prefix
            });
            if (!r.ok) return jsonResponse({
              error: 'Failed to list files',
              detail: r.text
            }, r.status, origin);
            // supabase storage list typically returns an array
            const files = Array.isArray(r.data) ? r.data : r.data?.data ?? r.data ?? [];
            return jsonResponse({
              ok: true,
              files
            }, 200, origin);
          }
        case 'sign_file':
          {
            const bucket = payload.bucket;
            const file = payload.file;
            const expiresIn = payload.expiresIn ?? 3600;
            if (!bucket || !file) return jsonResponse({
              error: 'Missing bucket or file'
            }, 400, origin);
            const r = await supabasePost(`/storage/v1/object/sign/${encodeURIComponent(bucket)}/${encodeURIComponent(file)}`, {
              expiresIn
            });
            if (!r.ok) return jsonResponse({
              error: 'Failed to sign file',
              detail: r.text
            }, r.status, origin);
            const signed = (r.data && (r.data.signedUrl || r.data.signed_url || r.data.signedURL || r.data.url)) ?? r.data ?? null;
            return jsonResponse({
              ok: true,
              signedUrl: signed
            }, 200, origin);
          }
        case 'download_file':
          {
            const bucket = payload.bucket;
            const file = payload.file;
            if (!bucket || !file) return jsonResponse({
              error: 'Missing bucket or file'
            }, 400, origin);
            const r = await supabasePost(`/storage/v1/object/sign/${encodeURIComponent(bucket)}/${encodeURIComponent(file)}`, {
              expiresIn: 60
            });
            if (!r.ok) return jsonResponse({
              error: 'Failed to get signed url',
              detail: r.text
            }, r.status, origin);
            const signed = (r.data && (r.data.signedUrl || r.data.signed_url || r.data.signedURL || r.data.url)) ?? r.data ?? null;
            return jsonResponse({
              ok: true,
              signedUrl: signed
            }, 200, origin);
          }
        case 'delete_file':
          {
            const bucket = payload.bucket;
            const file = payload.file;
            if (!bucket || !file) return jsonResponse({
              error: 'Missing bucket or file'
            }, 400, origin);
            const r = await supabaseDelete(`/storage/v1/object/${encodeURIComponent(bucket)}/${encodeURIComponent(file)}`);
            if (!r.ok) return jsonResponse({
              error: 'Failed to delete file',
              detail: r.text
            }, r.status, origin);
            return jsonResponse({
              ok: true
            }, 200, origin);
          }
        default:
          return jsonResponse({
            error: 'Unknown action'
          }, 400, origin);
      }
    } catch (e) {
      console.error({
        requestId,
        msg: 'action_failed',
        err: isErrorLike(e) ? String(e.message ?? e) : String(e)
      });
      return jsonResponse({
        error: 'Action failed',
        detail: isErrorLike(e) ? e.message ?? String(e) : String(e)
      }, 500, origin);
    }
  } catch (err) {
    console.error({
      requestId: makeRequestId(),
      msg: 'unhandled_error',
      err: isErrorLike(err) ? String(err.message ?? err) : String(err)
    });
    return jsonResponse({
      error: 'Internal error'
    }, 500, req.headers.get('origin'));
  }
});
